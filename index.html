<!DOCTYPE html>
<html lang="pl">
<head>
<meta charset="UTF-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>Obliczenia otworów w kantówce</title>
<style>
  body { font-family: Arial, sans-serif; max-width: 600px; margin: 20px auto; padding: 0 15px; }
  label { display: block; margin-top: 15px; }
  input[type=number] { width: 100%; padding: 8px; font-size: 16px; }
  button { margin-top: 20px; padding: 10px 15px; font-size: 16px; cursor: pointer; }
  .results { margin-top: 30px; }
  canvas { margin-top: 20px; border: 1px solid #ccc; width: 100%; max-width: 580px; height: 80px; }
  ul { padding-left: 20px; }
</style>
</head>
<body>

<h1>Obliczenia otworów w kantówce</h1>

<label for="kantowkaLength">Długość kantówki (mm):</label>
<input type="number" id="kantowkaLength" min="1" step="1" placeholder="np. 2000" />

<label for="otworWidth">Szerokość otworu (mm):</label>
<input type="number" id="otworWidth" min="1" step="1" placeholder="np. 50" />

<button id="calculateBtn">Oblicz</button>

<div class="results" id="results"></div>

<canvas id="schemat"></canvas>

<script>
  const maxDistance = 400; // max odstęp między krawędziami otworów w mm

  function calculateHoles(kantowkaLength, otworWidth) {
    if (kantowkaLength <= 0 || otworWidth <= 0) return null;

    // Minimalnie 2 otwory - na początku i na końcu
    // Odstęp to odległość między krawędziami otworów
    // Pozycja otworu to odległość od początku kantówki do środka otworu

    // Liczymy max ilość odstępów: odstęp max 400mm, więc ile max odstępów zmieści się w kantówce
    // Kantówka ma 2 krawędzie z otworami (początek i koniec), między nimi odstępy
    // Liczba otworów = liczba odstępów + 1
    // Odstęp liczony jako: odstęp między krawędziami otworów

    // Obliczamy max liczbę odstępów:
    // odstęp max = 400 mm
    // długość kantówki minus szerokość otworu (bo otwory na końcach)
    const availableLength = kantowkaLength - otworWidth;
    let maxIntervals = Math.ceil(availableLength / maxDistance);

    // Liczba otworów to maxIntervals + 1, ale minimalnie 2
    if (maxIntervals < 1) maxIntervals = 1;
    const holesCount = maxIntervals + 1;

    // Równe odstępy między krawędziami otworów:
    const interval = availableLength / maxIntervals;

    // Pozycje otworów (od początku kantówki do środka otworu)
    // Pierwszy otwór: środek na odległości otworWidth/2 od początku (krawędź otworu na 0)
    // Ostatni otwór: środek na odległości kantowkaLength - otworWidth/2 (krawędź na kantowkaLength)
    // Pozycje środków kolejnych otworów:
    let positions = [];
    for(let i = 0; i < holesCount; i++) {
      // Pozycja środka otworu:
      let pos = (otworWidth / 2) + i * interval;
      positions.push(pos);
    }

    // Odstępy między krawędziami otworów:
    // między otworami i i i+1 to: pozycja[i+1] - pozycja[i] - szerokość otworu
    let distances = [];
    for(let i=0; i<positions.length-1; i++) {
      distances.push(positions[i+1] - positions[i] - otworWidth);
    }

    return { holesCount, positions, distances };
  }

  function drawScheme(kantowkaLength, otworWidth, positions) {
    const canvas = document.getElementById('schemat');
    const ctx = canvas.getContext('2d');

    // ustaw rozmiar canvas zgodnie z rozdzielczością i szerokością ekranu
    canvas.width = canvas.clientWidth * window.devicePixelRatio;
    canvas.height = 80 * window.devicePixelRatio;
    ctx.scale(window.devicePixelRatio, window.devicePixelRatio);

    // skalowanie: długość kantówki do szerokości canvas (max 580px)
    const scale = 580 / kantowkaLength;

    ctx.clearRect(0, 0, canvas.width, canvas.height);

    // rysuj kantówkę jako prostokąt tła
    ctx.fillStyle = '#eee';
    ctx.fillRect(0, 20, kantowkaLength * scale, 40);

    // rysuj otwory jako ciemne prostokąty
    ctx.fillStyle = '#007ACC';
    positions.forEach(pos => {
      const x = (pos - otworWidth/2) * scale;
      ctx.fillRect(x, 20, otworWidth * scale, 40);
    });

    // dodaj podpisy (odległości od początku kantówki) nad otworami
    ctx.fillStyle = '#000';
    ctx.font = '12px Arial';
    ctx.textAlign = 'center';
    positions.forEach(pos => {
      ctx.fillText(Math.round(pos) + ' mm', pos * scale, 15);
    });
  }

  document.getElementById('calculateBtn').addEventListener('click', () => {
    const kantowkaLength = parseFloat(document.getElementById('kantowkaLength').value);
    const otworWidth = parseFloat(document.getElementById('otworWidth').value);

    if (isNaN(kantowkaLength) || kantowkaLength <= 0) {
      alert('Podaj poprawną długość kantówki.');
      return;
    }
    if (isNaN(otworWidth) || otworWidth <= 0 || otworWidth > kantowkaLength) {
      alert('Podaj poprawną szerokość otworu (mniejszą niż długość kantówki).');
      return;
    }

    const result = calculateHoles(kantowkaLength, otworWidth);

    if (!result) {
      alert('Błąd obliczeń.');
      return;
    }

    let html = `<p><strong>Liczba otworów:</strong> ${result.holesCount}</p>`;
    html += '<p><strong>Pozycje otworów (od środka otworu, w mm):</strong></p><ul>';
    result.positions.forEach((pos, i) => {
      html += `<li>Otwór ${i+1}: ${pos.toFixed(1)} mm</li>`;
    });
    html += '</ul>';

    html += '<p><strong>Odstępy między krawędziami otworów (mm):</strong></p><ul>';
    result.distances.forEach((dist, i) => {
      html += `<li>Między otworem ${i+1} a ${i+2}: ${dist.toFixed(1)} mm</li>`;
    });
    html += '</ul>';

    document.getElementById('results').innerHTML = html;
    drawScheme(kantowkaLength, otworWidth, result.positions);
  });
</script>

</body>
</html>
